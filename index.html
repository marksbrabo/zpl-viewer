<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ZPL Viewer &mdash; Visualizador de Etiquetas Shopee</title>
<script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.2/dist/jspdf.umd.min.js"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box}
:root{
  --bg:#0f1117;--surface:#1a1d27;--surface2:#242734;--border:#2e3144;
  --text:#e4e4e7;--text2:#a0a0ab;--accent:#3b82f6;--accent-hover:#2563eb;
  --success:#22c55e;--danger:#ef4444;
}
body{font-family:'Segoe UI',system-ui,-apple-system,sans-serif;background:var(--bg);color:var(--text);height:100vh;display:flex;flex-direction:column;overflow:hidden}

/* Header */
header{background:var(--surface);border-bottom:1px solid var(--border);padding:0 24px;height:56px;display:flex;align-items:center;gap:16px;flex-shrink:0}
header h1{font-size:18px;font-weight:700;display:flex;align-items:center;gap:8px}
header h1 span{color:var(--accent)}
.header-actions{margin-left:auto;display:flex;gap:8px;align-items:center}

/* Buttons */
.btn{padding:8px 16px;border-radius:8px;border:1px solid var(--border);background:var(--surface2);color:var(--text);font-size:13px;font-weight:500;cursor:pointer;transition:all .15s;display:inline-flex;align-items:center;gap:6px}
.btn:hover{background:var(--border);border-color:#3e4256}
.btn-primary{background:var(--accent);border-color:var(--accent);color:#fff}
.btn-primary:hover{background:var(--accent-hover)}
.btn-danger{background:transparent;border-color:var(--danger);color:var(--danger)}
.btn-danger:hover{background:var(--danger);color:#fff}
.btn-sm{padding:5px 10px;font-size:12px}

/* Main Layout */
main{flex:1;display:flex;overflow:hidden}

/* Editor Panel */
.editor-panel{width:40%;display:flex;flex-direction:column;border-right:1px solid var(--border);min-width:280px}
.panel-header{padding:12px 16px;background:var(--surface);border-bottom:1px solid var(--border);display:flex;align-items:center;gap:12px;flex-shrink:0}
.panel-header h2{font-size:14px;font-weight:600;color:var(--text2)}
.panel-header .badge{background:var(--accent);color:#fff;font-size:11px;padding:2px 8px;border-radius:12px;font-weight:600}
.editor-area{flex:1;position:relative}
.editor-area textarea{width:100%;height:100%;background:var(--bg);color:#c5c8d4;border:none;padding:16px;font-family:'Cascadia Code','Fira Code','JetBrains Mono',monospace;font-size:13px;line-height:1.6;resize:none;outline:none;tab-size:4}
.editor-area textarea::placeholder{color:#4a4d5e}
.editor-footer{padding:8px 16px;background:var(--surface);border-top:1px solid var(--border);display:flex;align-items:center;gap:12px;flex-shrink:0;font-size:12px;color:var(--text2)}

/* Preview Panel */
.preview-panel{flex:1;display:flex;flex-direction:column;min-width:300px}
.preview-controls{padding:10px 16px;background:var(--surface);border-bottom:1px solid var(--border);display:flex;align-items:center;gap:10px;flex-wrap:wrap;flex-shrink:0}
.control-group{display:flex;align-items:center;gap:5px}
.control-group label{font-size:12px;color:var(--text2);white-space:nowrap}
.control-group select,.control-group input[type=number]{background:var(--surface2);border:1px solid var(--border);color:var(--text);padding:4px 8px;border-radius:6px;font-size:12px;outline:none}
.control-group select:focus,.control-group input:focus{border-color:var(--accent)}
.control-group input[type=number]{width:55px}
.preview-area{flex:1;overflow:auto;padding:20px;background:var(--bg);display:flex;flex-wrap:wrap;gap:12px;align-content:flex-start;justify-content:center}

/* View modes */
.preview-area.view-grid{justify-content:center}
.preview-area.view-list{flex-direction:column;align-items:center}

/* Label cards */
.label-card{background:var(--surface);border:1px solid var(--border);border-radius:8px;overflow:hidden;transition:box-shadow .2s}
.label-card:hover{box-shadow:0 4px 20px rgba(59,130,246,.15)}
.label-card .card-header{padding:5px 10px;background:var(--surface2);border-bottom:1px solid var(--border);font-size:11px;color:var(--text2);display:flex;justify-content:space-between;align-items:center}
.label-card canvas{display:block;image-rendering:pixelated;image-rendering:-moz-crisp-edges;image-rendering:crisp-edges}

/* Bitmap section (full bitmap view) */
.bitmap-section{margin-bottom:16px;width:100%}
.bitmap-section h3{font-size:13px;color:var(--text2);margin-bottom:8px;padding-left:4px}
.bitmap-labels{display:flex;flex-wrap:wrap;gap:10px;justify-content:center}

/* Drop Zone */
.drop-zone{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;flex-direction:column;gap:12px;background:rgba(15,17,23,.92);border:2px dashed var(--accent);border-radius:12px;margin:12px;opacity:0;pointer-events:none;transition:opacity .2s;z-index:10}
.drop-zone.active{opacity:1;pointer-events:all}
.drop-zone svg{width:48px;height:48px;color:var(--accent)}
.drop-zone p{font-size:15px;color:var(--text2)}
.drop-zone p strong{color:var(--text)}

/* Empty State */
.empty-state{text-align:center;padding:60px 24px;color:var(--text2)}
.empty-state svg{width:64px;height:64px;margin-bottom:16px;color:var(--border)}
.empty-state h3{font-size:16px;color:var(--text);margin-bottom:8px}
.empty-state p{font-size:13px;line-height:1.6}

/* Resizer */
.resizer{width:4px;cursor:col-resize;background:transparent;transition:background .2s;flex-shrink:0}
.resizer:hover,.resizer.dragging{background:var(--accent)}

/* Responsive */
@media(max-width:768px){
  main{flex-direction:column}
  .editor-panel{width:100%;height:35%;border-right:none;border-bottom:1px solid var(--border);min-width:unset}
  .preview-panel{min-width:unset}
  .resizer{display:none}
}

/* Toast */
.toast{position:fixed;bottom:24px;right:24px;background:var(--surface2);border:1px solid var(--border);border-radius:10px;padding:12px 20px;font-size:13px;color:var(--text);box-shadow:0 8px 30px rgba(0,0,0,.4);transform:translateY(100px);opacity:0;transition:all .3s;z-index:100}
.toast.show{transform:translateY(0);opacity:1}
.toast.success{border-color:var(--success)}
.toast.error{border-color:var(--danger)}

/* Zoom indicator */
.zoom-indicator{font-size:11px;color:var(--accent);font-weight:600}

/* Paper mockup */
.paper-strip{background:#fff;border-radius:4px;display:flex;overflow:hidden;box-shadow:0 2px 12px rgba(0,0,0,.3)}
.paper-strip .paper-cell{display:flex;align-items:center;justify-content:center;overflow:hidden;position:relative}
.paper-strip .paper-cell+.paper-cell{border-left:1px dashed #ccc}
.paper-strip .paper-cell canvas{image-rendering:pixelated;image-rendering:-moz-crisp-edges;image-rendering:crisp-edges}
.paper-strip .cell-num{position:absolute;top:2px;left:4px;font-size:9px;color:#aaa;font-weight:600}

/* Separator */
.sep{width:1px;height:20px;background:var(--border);margin:0 2px}
</style>
</head>
<body>

<header>
  <h1>
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><path d="M7 7h3v3H7zM14 7h3v3h-3zM7 14h3v3H7zM14 14h3v3h-3z"/></svg>
    <span>ZPL</span> Viewer
  </h1>
  <span style="font-size:12px;color:var(--text2)">Etiquetas Shopee &bull; 80&times;24mm (2 col.)</span>
  <div class="header-actions">
    <button class="btn btn-sm" id="btnLoad" title="Carregar arquivo">
      <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>
      Carregar
    </button>
    <button class="btn btn-sm btn-primary" id="btnRender" title="Ctrl+Enter">
      <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="5 3 19 12 5 21 5 3"/></svg>
      Renderizar
    </button>
    <button class="btn btn-sm btn-danger" id="btnClear" title="Limpar">
      <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg>
      Limpar
    </button>
  </div>
</header>

<main>
  <div class="editor-panel" id="editorPanel">
    <div class="panel-header">
      <h2>Codigo ZPL</h2>
      <span class="badge" id="labelCount">0 etiquetas</span>
    </div>
    <div class="editor-area" id="editorArea">
      <div class="drop-zone" id="dropZone">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>
        <p>Solte o arquivo <strong>.txt / .zpl</strong> aqui</p>
      </div>
      <textarea id="zplInput" placeholder="Cole o codigo ZPL aqui ou arraste um arquivo .txt / .zpl ..." spellcheck="false"></textarea>
    </div>
    <div class="editor-footer">
      <span id="charCount">0 caracteres</span>
      <span style="margin-left:auto">Ctrl+Enter para renderizar</span>
    </div>
  </div>

  <div class="resizer" id="resizer"></div>

  <div class="preview-panel">
    <div class="preview-controls">
      <div class="control-group">
        <label>Zoom:</label>
        <input type="range" id="zoomRange" min="50" max="500" value="200" style="width:90px;accent-color:var(--accent)">
        <span class="zoom-indicator" id="zoomLabel">200%</span>
      </div>
      <div class="sep"></div>
      <div class="control-group">
        <label>Fundo:</label>
        <select id="bgColor">
          <option value="#ffffff">Branco</option>
          <option value="#f5f5dc">Bege</option>
          <option value="#fffdd0">Creme</option>
        </select>
      </div>
      <div class="sep"></div>
      <div class="control-group">
        <label>Visualizar:</label>
        <select id="viewMode">
          <option value="paper" selected>Papel 80&times;24mm (2 colunas)</option>
          <option value="individual">Etiquetas individuais</option>
          <option value="raw">Bitmap original completo</option>
        </select>
      </div>
      <div style="margin-left:auto;display:flex;gap:8px">
        <button class="btn btn-sm" id="btnExportPng">
          <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
          PNG
        </button>
        <button class="btn btn-sm" id="btnExportPdf">
          <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
          PDF 80&times;24mm
        </button>
      </div>
    </div>
    <div class="preview-area view-grid" id="previewArea">
      <div class="empty-state" id="emptyState">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="3" y="3" width="18" height="18" rx="2"/><path d="M7 7h3v3H7zM14 7h3v3h-3zM7 14h3v3H7z"/></svg>
        <h3>Nenhuma etiqueta renderizada</h3>
        <p>Cole o codigo ZPL no editor ao lado e clique em <strong>Renderizar</strong>,<br>ou arraste um arquivo diretamente no editor.</p>
      </div>
    </div>
  </div>
</main>

<div class="toast" id="toast"></div>
<input type="file" id="fileInput" accept=".txt,.zpl,.prn" hidden multiple>

<script>
// ──────────── Elements ────────────
const zplInput    = document.getElementById('zplInput');
const previewArea = document.getElementById('previewArea');
const emptyState  = document.getElementById('emptyState');
const labelCount  = document.getElementById('labelCount');
const charCount   = document.getElementById('charCount');
const btnRender   = document.getElementById('btnRender');
const btnClear    = document.getElementById('btnClear');
const btnLoad     = document.getElementById('btnLoad');
const btnPng      = document.getElementById('btnExportPng');
const btnPdf      = document.getElementById('btnExportPdf');
const fileInput   = document.getElementById('fileInput');
const dropZone    = document.getElementById('dropZone');
const editorArea  = document.getElementById('editorArea');
const zoomRange   = document.getElementById('zoomRange');
const zoomLabel   = document.getElementById('zoomLabel');
const bgColor     = document.getElementById('bgColor');
const viewMode    = document.getElementById('viewMode');
const toastEl     = document.getElementById('toast');
const resizer     = document.getElementById('resizer');
const editorPanel = document.getElementById('editorPanel');

let renderedLabels = []; // individual label canvases
let rawBitmaps = [];     // full decoded bitmaps

// ──────────── Toast ────────────
function toast(msg, type='success') {
  toastEl.textContent = msg;
  toastEl.className = 'toast show ' + type;
  clearTimeout(toastEl._t);
  toastEl._t = setTimeout(() => toastEl.className = 'toast', 3000);
}

// ──────────── Char count ────────────
zplInput.addEventListener('input', () => {
  charCount.textContent = zplInput.value.length.toLocaleString('pt-BR') + ' caracteres';
});

// ──────────── File load ────────────
btnLoad.addEventListener('click', () => fileInput.click());
fileInput.addEventListener('change', e => {
  if (!e.target.files.length) return;
  readFile(e.target.files[0]);
  fileInput.value = '';
});

function readFile(file) {
  const reader = new FileReader();
  reader.onload = ev => {
    zplInput.value = ev.target.result;
    zplInput.dispatchEvent(new Event('input'));
    toast('Arquivo carregado: ' + file.name);
  };
  reader.readAsText(file);
}

// ──────────── Drag & Drop ────────────
['dragenter','dragover'].forEach(ev =>
  editorArea.addEventListener(ev, e => { e.preventDefault(); dropZone.classList.add('active'); })
);
['dragleave','drop'].forEach(ev =>
  editorArea.addEventListener(ev, e => { e.preventDefault(); dropZone.classList.remove('active'); })
);
editorArea.addEventListener('drop', e => {
  const f = e.dataTransfer.files[0];
  if (f) readFile(f);
});

// ──────────── Resizer ────────────
let isResizing = false;
resizer.addEventListener('mousedown', () => {
  isResizing = true;
  resizer.classList.add('dragging');
  document.body.style.cursor = 'col-resize';
  document.body.style.userSelect = 'none';
});
document.addEventListener('mousemove', e => {
  if (!isResizing) return;
  const pct = (e.clientX / window.innerWidth) * 100;
  if (pct > 15 && pct < 75) editorPanel.style.width = pct + '%';
});
document.addEventListener('mouseup', () => {
  if (isResizing) {
    isResizing = false;
    resizer.classList.remove('dragging');
    document.body.style.cursor = '';
    document.body.style.userSelect = '';
  }
});

// ──────────── Keyboard shortcuts ────────────
document.addEventListener('keydown', e => {
  if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
    e.preventDefault();
    renderZPL();
  }
});

// ──────────── Buttons ────────────
btnRender.addEventListener('click', renderZPL);
btnClear.addEventListener('click', () => {
  zplInput.value = '';
  zplInput.dispatchEvent(new Event('input'));
  previewArea.innerHTML = '';
  previewArea.appendChild(emptyState);
  emptyState.style.display = '';
  renderedLabels = [];
  rawBitmaps = [];
  labelCount.textContent = '0 etiquetas';
});

// ──────────── Zoom ────────────
zoomRange.addEventListener('input', () => {
  zoomLabel.textContent = zoomRange.value + '%';
  if (viewMode.value === 'paper') applyPaperZoom();
  else applyZoom();
});

function applyZoom() {
  const scale = zoomRange.value / 100;
  document.querySelectorAll('.label-card canvas').forEach(c => {
    const bw = c._bmpW || c._origW;
    const bh = c._bmpH || c._origH;
    c.style.width = (bw * scale) + 'px';
    c.style.height = (bh * scale) + 'px';
  });
}

function applyPaperZoom() {
  const scale = zoomRange.value / 100;
  document.querySelectorAll('.paper-strip').forEach(strip => {
    strip.style.transform = `scale(${scale})`;
    strip.style.transformOrigin = 'top left';
    strip.style.marginBottom = (strip._paperH * (scale - 1) + 12) + 'px';
    strip.style.marginRight = (strip._paperW * (scale - 1)) + 'px';
  });
}

// ──────────── View mode / bg change ────────────
viewMode.addEventListener('change', () => { if (rawBitmaps.length) displayLabels(); });
bgColor.addEventListener('change', () => { if (rawBitmaps.length) displayLabels(); });

// ══════════════════════════════════════════════
//  ZPL PARSING
// ══════════════════════════════════════════════

function parseZPL(raw) {
  const bitmaps = [];

  // Z64: base64 of zlib-compressed bitmap
  const z64Regex = /~DG([^,]*),(\d+),(\d+),\s*:Z64:([^:]+):([0-9A-Fa-f]{4})/g;
  let match;
  while ((match = z64Regex.exec(raw)) !== null) {
    const bytesPerRow = parseInt(match[3]);
    const z64data = match[4];
    try {
      const bin = atob(z64data);
      const compressed = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; i++) compressed[i] = bin.charCodeAt(i);
      const bitmap = pako.inflate(compressed);
      const width = bytesPerRow * 8;
      const height = Math.floor(bitmap.length / bytesPerRow);
      if (width > 0 && height > 0) bitmaps.push({ bitmap, width, height, bytesPerRow });
    } catch (err) {
      console.warn('Z64 decode error:', err);
    }
  }

  // B64: raw base64 bitmap
  const b64Regex = /~DG([^,]*),(\d+),(\d+),\s*:B64:([^:]+):([0-9A-Fa-f]{4})/g;
  while ((match = b64Regex.exec(raw)) !== null) {
    const bytesPerRow = parseInt(match[3]);
    const b64data = match[4];
    try {
      const bin = atob(b64data);
      const bitmap = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; i++) bitmap[i] = bin.charCodeAt(i);
      const width = bytesPerRow * 8;
      const height = Math.floor(bitmap.length / bytesPerRow);
      if (width > 0 && height > 0) bitmaps.push({ bitmap, width, height, bytesPerRow });
    } catch (err) {
      console.warn('B64 decode error:', err);
    }
  }

  return bitmaps;
}

// ══════════════════════════════════════════════
//  BITMAP → CANVAS helper
// ══════════════════════════════════════════════

function bitmapToCanvas(bitmap, bytesPerRow, x, y, w, h, rotate90) {
  // Upscale factor for sharp rendering (each bitmap pixel -> NxN canvas pixels)
  const S = 3;
  // If rotated 90° CW: output dimensions are swapped
  const outW = rotate90 ? h : w;
  const outH = rotate90 ? w : h;

  const canvas = document.createElement('canvas');
  canvas.width = outW * S;
  canvas.height = outH * S;
  canvas._bmpW = outW;
  canvas._bmpH = outH;

  const ctx = canvas.getContext('2d');
  ctx.imageSmoothingEnabled = false;
  const bg = bgColor.value;
  const bgR = parseInt(bg.slice(1,3),16);
  const bgG = parseInt(bg.slice(3,5),16);
  const bgB = parseInt(bg.slice(5,7),16);

  const imgData = ctx.createImageData(outW * S, outH * S);
  const px = imgData.data;

  for (let oy = 0; oy < outH; oy++) {
    for (let ox = 0; ox < outW; ox++) {
      // Map rotated coords back to original bitmap coords
      let srcCol, srcRow;
      if (rotate90) {
        // 90° CW: rotated(rx,ry) <- original(ry, H-1-rx)
        srcCol = x + oy;
        srcRow = y + (h - 1 - ox);
      } else {
        srcCol = x + ox;
        srcRow = y + oy;
      }

      const byteIdx = srcRow * bytesPerRow + Math.floor(srcCol / 8);
      const bitIdx = 7 - (srcCol % 8);
      const bit = (bitmap[byteIdx] >> bitIdx) & 1;
      const r = bit ? 0 : bgR;
      const g = bit ? 0 : bgG;
      const b = bit ? 0 : bgB;

      for (let sy = 0; sy < S; sy++) {
        for (let sx = 0; sx < S; sx++) {
          const pi = ((oy * S + sy) * outW * S + (ox * S + sx)) * 4;
          px[pi] = r; px[pi+1] = g; px[pi+2] = b; px[pi+3] = 255;
        }
      }
    }
  }

  ctx.putImageData(imgData, 0, 0);
  return canvas;
}

// ══════════════════════════════════════════════
//  GRID DETECTION — split bitmap into cells
// ══════════════════════════════════════════════

function detectGrid(bitmap, bytesPerRow, width, height) {
  // Find blank rows (horizontal separators)
  function rowBlack(r) {
    for (let b = 0; b < bytesPerRow; b++) {
      if (bitmap[r * bytesPerRow + b] !== 0) return true;
    }
    return false;
  }

  // Find blank columns (vertical separators)
  function colBlack(c, rStart, rEnd) {
    const byteCol = Math.floor(c / 8);
    const bitMask = 1 << (7 - (c % 8));
    for (let r = rStart; r <= rEnd; r++) {
      if (bitmap[r * bytesPerRow + byteCol] & bitMask) return true;
    }
    return false;
  }

  // Detect horizontal bands (content rows separated by blank rows)
  const rowBands = [];
  let inContent = false;
  let bandStart = 0;

  for (let r = 0; r < height; r++) {
    const hasContent = rowBlack(r);
    if (!inContent && hasContent) {
      bandStart = r;
      inContent = true;
    } else if (inContent && !hasContent) {
      rowBands.push({ start: bandStart, end: r - 1 });
      inContent = false;
    }
  }
  if (inContent) rowBands.push({ start: bandStart, end: height - 1 });

  // Merge bands that are close together (< 15px gap = same label row)
  // QR code (~173px) and text (~7px lines with 1-2px gaps) belong together
  const mergedRows = [];
  let current = null;
  for (const band of rowBands) {
    if (!current) {
      current = { start: band.start, end: band.end };
    } else if (band.start - current.end <= 15) {
      current.end = band.end;
    } else {
      mergedRows.push(current);
      current = { start: band.start, end: band.end };
    }
  }
  if (current) mergedRows.push(current);

  if (mergedRows.length === 0) return [];

  // Detect vertical columns using the first merged row
  const ref = mergedRows[0];
  const colBands = [];
  inContent = false;

  for (let c = 0; c < width; c++) {
    const hasContent = colBlack(c, ref.start, ref.end);
    if (!inContent && hasContent) {
      bandStart = c;
      inContent = true;
    } else if (inContent && !hasContent) {
      colBands.push({ start: bandStart, end: c - 1 });
      inContent = false;
    }
  }
  if (inContent) colBands.push({ start: bandStart, end: width - 1 });

  // Build cell list
  const cells = [];
  for (const row of mergedRows) {
    for (const col of colBands) {
      cells.push({
        x: col.start,
        y: row.start,
        w: col.end - col.start + 1,
        h: row.end - row.start + 1
      });
    }
  }

  return cells;
}

// ══════════════════════════════════════════════
//  QR/TEXT SPLIT + COMPOSED LABEL
// ══════════════════════════════════════════════

function findQrTextSplit(bitmap, bytesPerRow, cellX, cellY, cellW, cellH) {
  function rowHasContent(r) {
    for (let c = 0; c < cellW; c++) {
      const bx = cellX + c;
      const by = cellY + r;
      const byteIdx = by * bytesPerRow + Math.floor(bx / 8);
      const bitIdx = 7 - (bx % 8);
      if ((bitmap[byteIdx] >> bitIdx) & 1) return true;
    }
    return false;
  }

  let blankRun = 0;
  let lastContentRow = -1;
  for (let r = 0; r < cellH; r++) {
    if (rowHasContent(r)) {
      if (blankRun > 3 && lastContentRow > 50) {
        return { qrH: lastContentRow + 1, textY: r, textH: cellH - r };
      }
      blankRun = 0;
      lastContentRow = r;
    } else {
      blankRun++;
    }
  }
  return { qrH: cellH, textY: cellH, textH: 0 };
}

function composeLabel(bitmap, bytesPerRow, cell) {
  const { x, y, w, h } = cell;
  const { qrH, textY, textH } = findQrTextSplit(bitmap, bytesPerRow, x, y, w, h);

  // If no text detected, just rotate the whole thing
  if (textH === 0) return bitmapToCanvas(bitmap, bytesPerRow, x, y, w, h, true);

  // Composed layout (all rotated 90° CW):
  //   [textCol2 | textCol1 | QR]
  // QR rotated: qrH wide × w tall
  // Text half rotated: textH × halfW → scaled to textColW × w
  const halfW = Math.ceil(w / 2);
  const half2W = w - halfW;
  const targetH = w;
  const textScale = targetH / halfW;
  const textColW = Math.round(textH * textScale);
  const qrColW = qrH;
  const totalW = textColW * 2 + qrColW;

  const S = 3;
  const cW = totalW * S, cH = targetH * S;
  const canvas = document.createElement('canvas');
  canvas.width = cW;
  canvas.height = cH;
  canvas._bmpW = totalW;
  canvas._bmpH = targetH;

  const bg = bgColor.value;
  const bgR = parseInt(bg.slice(1,3),16);
  const bgG = parseInt(bg.slice(3,5),16);
  const bgB = parseInt(bg.slice(5,7),16);

  const ctx = canvas.getContext('2d');
  ctx.imageSmoothingEnabled = false;
  const imgData = ctx.createImageData(cW, cH);
  const px = imgData.data;

  function getBit(bx, by) {
    const byteIdx = by * bytesPerRow + Math.floor(bx / 8);
    const bitIdx = 7 - (bx % 8);
    return (bitmap[byteIdx] >> bitIdx) & 1;
  }

  function setPixel(outX, outY, isBlack) {
    const r = isBlack ? 0 : bgR;
    const g = isBlack ? 0 : bgG;
    const b = isBlack ? 0 : bgB;
    for (let sy = 0; sy < S; sy++) {
      for (let sx = 0; sx < S; sx++) {
        const pi = ((outY * S + sy) * cW + (outX * S + sx)) * 4;
        px[pi] = r; px[pi+1] = g; px[pi+2] = b; px[pi+3] = 255;
      }
    }
  }

  // QR (right side, rotated 90° CW)
  // output(ox,oy) -> source(oy, qrH-1-ox) relative to QR origin
  for (let ox = 0; ox < qrColW; ox++) {
    for (let oy = 0; oy < targetH; oy++) {
      const srcX = x + oy;
      const srcY = y + (qrH - 1 - ox);
      setPixel(textColW * 2 + ox, oy, getBit(srcX, srcY));
    }
  }

  // Text half 1 — left half of text → middle column
  // Rotated 90° CW + scaled: output(ox,oy) maps to text source
  for (let ox = 0; ox < textColW; ox++) {
    for (let oy = 0; oy < targetH; oy++) {
      const srcCol = Math.floor(oy * halfW / targetH);
      const srcRow = Math.floor((textColW - 1 - ox) * textH / textColW);
      setPixel(textColW + ox, oy, getBit(x + srcCol, y + textY + srcRow));
    }
  }

  // Text half 2 — right half of text → left column
  for (let ox = 0; ox < textColW; ox++) {
    for (let oy = 0; oy < targetH; oy++) {
      const srcCol = halfW + Math.floor(oy * half2W / targetH);
      const srcRow = Math.floor((textColW - 1 - ox) * textH / textColW);
      setPixel(ox, oy, getBit(x + srcCol, y + textY + srcRow));
    }
  }

  ctx.putImageData(imgData, 0, 0);
  return canvas;
}

// ══════════════════════════════════════════════
//  RENDER + DISPLAY
// ══════════════════════════════════════════════

function renderZPL() {
  const raw = zplInput.value.trim();
  if (!raw) { toast('Cole o codigo ZPL primeiro', 'error'); return; }

  rawBitmaps = parseZPL(raw);
  if (!rawBitmaps.length) { toast('Nenhum bloco ~DG encontrado no ZPL', 'error'); return; }

  displayLabels();
}

function getAllCells() {
  const allCells = [];
  rawBitmaps.forEach(bmp => {
    const cells = detectGrid(bmp.bitmap, bmp.bytesPerRow, bmp.width, bmp.height);
    cells.forEach(cell => allCells.push({ bmp, cell }));
  });
  return allCells;
}

function displayLabels() {
  renderedLabels = [];
  previewArea.innerHTML = '';
  emptyState.style.display = 'none';

  const mode = viewMode.value;

  if (mode === 'raw') {
    rawBitmaps.forEach((bmp, bi) => {
      const card = makeCard(
        `Bitmap ${bi + 1}`,
        `${bmp.width}&times;${bmp.height}px`,
        bitmapToCanvas(bmp.bitmap, bmp.bytesPerRow, 0, 0, bmp.width, bmp.height)
      );
      previewArea.appendChild(card);
      renderedLabels.push({ canvas: card.querySelector('canvas'), width: bmp.width, height: bmp.height });
    });

  } else if (mode === 'individual') {
    // Composed: QR right + 2 text columns left
    const allCells = getAllCells();
    const wrap = document.createElement('div');
    wrap.className = 'bitmap-labels';
    allCells.forEach(({ bmp, cell }, i) => {
      const canvas = composeLabel(bmp.bitmap, bmp.bytesPerRow, cell);
      const bw = canvas._bmpW, bh = canvas._bmpH;
      const card = makeCard(`#${i+1}`, `${bw}&times;${bh}px`, canvas);
      wrap.appendChild(card);
      renderedLabels.push({ canvas, width: bw, height: bh });
    });
    previewArea.appendChild(wrap);

  } else {
    // Paper mode: 83x24mm (40mm + 3mm gap + 40mm), 2 columns
    const allCells = getAllCells();
    const CELL_W_MM = 40, PAPER_H_MM = 24, COLS = 2, GAP_MM = 3;
    const PAPER_W_MM = CELL_W_MM * COLS + GAP_MM; // 83mm
    const DPMM = 8;
    const PX_PER_MM = 4;

    for (let i = 0; i < allCells.length; i += COLS) {
      const strip = document.createElement('div');
      strip.className = 'paper-strip';
      strip.style.width = (PAPER_W_MM * PX_PER_MM) + 'px';
      strip.style.height = (PAPER_H_MM * PX_PER_MM) + 'px';
      strip._paperW = PAPER_W_MM * PX_PER_MM;
      strip._paperH = PAPER_H_MM * PX_PER_MM;

      for (let c = 0; c < COLS; c++) {
        const idx = i + c;
        const cellDiv = document.createElement('div');
        cellDiv.className = 'paper-cell';
        cellDiv.style.width = (CELL_W_MM * PX_PER_MM) + 'px';
        cellDiv.style.height = (PAPER_H_MM * PX_PER_MM) + 'px';
        // Add 3mm gap after the first column
        if (c === 1) cellDiv.style.marginLeft = (GAP_MM * PX_PER_MM) + 'px';

        if (idx < allCells.length) {
          const { bmp, cell } = allCells[idx];
          const canvas = composeLabel(bmp.bitmap, bmp.bytesPerRow, cell);
          const bw = canvas._bmpW, bh = canvas._bmpH;

          // Scale composed label to fit within 38.5x24mm
          const contentWmm = bw / DPMM;
          const contentHmm = bh / DPMM;
          const scaleW = CELL_W_MM / contentWmm;
          const scaleH = PAPER_H_MM / contentHmm;
          const scale = Math.min(scaleW, scaleH);
          const dispW = contentWmm * scale * PX_PER_MM;
          const dispH = contentHmm * scale * PX_PER_MM;

          canvas.style.width = dispW + 'px';
          canvas.style.height = dispH + 'px';
          canvas._paperMode = true;

          const num = document.createElement('span');
          num.className = 'cell-num';
          num.textContent = '#' + (idx + 1);
          cellDiv.appendChild(num);
          cellDiv.appendChild(canvas);
          renderedLabels.push({ canvas, width: bw, height: bh });
        }

        strip.appendChild(cellDiv);
      }

      previewArea.appendChild(strip);
    }
  }

  const count = renderedLabels.length;
  labelCount.textContent = count + ' etiqueta' + (count !== 1 ? 's' : '');
  if (mode !== 'paper') applyZoom();
  else applyPaperZoom();
  toast(count + ' etiqueta(s) renderizada(s)');
}

function makeCard(title, subtitle, canvas) {
  const card = document.createElement('div');
  card.className = 'label-card';
  const hdr = document.createElement('div');
  hdr.className = 'card-header';
  hdr.innerHTML = `<span>${title}</span><span>${subtitle}</span>`;
  card.appendChild(hdr);
  // _origW/_origH = canvas pixel size; _bmpW/_bmpH = original bitmap size (for zoom)
  canvas._origW = canvas.width;
  canvas._origH = canvas.height;
  card.appendChild(canvas);
  return card;
}

// ──────────── Export PNG ────────────
btnPng.addEventListener('click', () => {
  if (!renderedLabels.length) { toast('Renderize primeiro', 'error'); return; }
  renderedLabels.forEach((lbl, i) => {
    const link = document.createElement('a');
    link.download = `etiqueta_${i + 1}.png`;
    link.href = lbl.canvas.toDataURL('image/png');
    link.click();
  });
  toast(renderedLabels.length + ' PNG(s) exportado(s)');
});

// ──────────── Export PDF 80x24mm (2 colunas de 40mm, rotacao 90° CW) ────────────
btnPdf.addEventListener('click', () => {
  if (!rawBitmaps.length) { toast('Renderize primeiro', 'error'); return; }

  const allCells = getAllCells();
  if (!allCells.length) { toast('Nenhuma etiqueta detectada', 'error'); return; }

  const { jsPDF } = window.jspdf;
  const CELL_W = 40, PAPER_H = 24, COLS = 2, GAP = 3;
  const PAPER_W = CELL_W * COLS + GAP; // 83mm
  const DPMM = 8;

  const doc = new jsPDF({ orientation: 'l', unit: 'mm', format: [PAPER_H, PAPER_W] });

  let col = 0;
  let pageStarted = true;

  allCells.forEach(({ bmp, cell }, i) => {
    if (col === 0 && !pageStarted) {
      doc.addPage([PAPER_H, PAPER_W]);
      pageStarted = true;
    }

    // Generate composed canvas (QR right + 2 text columns left)
    const canvas = composeLabel(bmp.bitmap, bmp.bytesPerRow, cell);
    const bw = canvas._bmpW, bh = canvas._bmpH;

    // Content size in mm
    const contentW = bw / DPMM;
    const contentH = bh / DPMM;

    // Scale proportionally to fit within CELL_W x PAPER_H
    const scaleW = CELL_W / contentW;
    const scaleH = PAPER_H / contentH;
    const scale = Math.min(scaleW, scaleH);
    const drawW = contentW * scale;
    const drawH = contentH * scale;

    // Center within cell, accounting for 3mm gap between columns
    // Col 0: x = 0..CELL_W, Col 1: x = CELL_W+GAP..PAPER_W
    const cellStartX = col * (CELL_W + GAP);
    const xOffset = cellStartX + (CELL_W - drawW) / 2;
    const yOffset = (PAPER_H - drawH) / 2;

    const imgData = canvas.toDataURL('image/png');
    doc.addImage(imgData, 'PNG', xOffset, yOffset, drawW, drawH);

    col++;
    if (col >= COLS) {
      col = 0;
      pageStarted = false;
    }
  });

  doc.save('etiquetas_shopee_80x24mm.pdf');
  toast('PDF exportado — ' + allCells.length + ' etiquetas rotacionadas em paginas 80x24mm');
});
</script>
</body>
</html>
